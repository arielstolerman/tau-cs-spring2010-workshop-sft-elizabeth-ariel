<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<meta name="verify-v1" content="l2SJjXDq6mUozEk+2u3UkzdEwtXKch0i0/3AkAr9sFA=" />
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<title>The SFT Algorithm</title>
		<link rel="shortcut icon" href="graphics/site_icon.ico">
		<link rel="stylesheet" href="style_sheet.css" type="text/css">
		<link rel="shortcut icon" href="icon.png">
	</head>

	<body>
		<center>
		<div id="id_content">
		
			<div id="id_title">
				<h1><font color="white">The SFT Algorithm</font></h1>
			</div>
			
			<div id="id_main">
				<b><center>
				 <h3>Learning and Coding Theory Workshop</h3>
				 <h2>The Java SFT Library</h2> 
				</center></b>
				
				<h3>Summary</h3>
				The Java SFT library allows users to use the public SFT methods for calculating a list of elements with significant Fourier
				coefficients, and an approximation of these coefficients. The library includes two public packages:
				<ul>
					<li>
						<b>SFT</b>: main package, includes the SFT implementation.
					</li>
					<li>
						<b>Function</b>: a package with data structures to describe general user-defined functions, as part of the
						SFT methods input, for the function-query (see the paper for details).
					</li>
				</ul>
				The SFT main package allows the user to call the SFT calculation in 6 variations:
				<ul>
					<li>
						<b>Function domain</b>: input function is either Cartesian product of finite groups (Z<sub>N1</sub> x ... x Z<sub>Nk</sub>)
						described by a list of N<sub>j</sub>'s or an Abelian group described by a list of N<sub>j</sub>'s and the
						corresponding generators g<sub>j</sub>'s.
					</li>
					<li>
						<b>Random subsets calculation method</b>: as detailed in the paper, the approximation is based on a set of elements in G, Q, which is
						defined as {x-y | x in A, y in Btl, t=1,...,k, l=1,...,log(Nt)}, where A and Btl are randomly generated sets of elements in G.
						Set A is of defined to be of size m<sub>A</sub> and sets Btl are defined to be of maximum size of m<sub>B</sub>.<br>
						The user is given two options to determine m<sub>A</sub> and m<sub>B</sub>: either give these variables directly or the more precise
						way by giving the algorithm all parameters needed to calculate m<sub>A</sub> and m<sub>B</sub> as described in the paper (p. 57):<br>
						<center>
						m<sub>A</sub> = &Theta;((||f||<sub>&infin;</sub>/&eta;)<sup>2</sup> * ln(1/&delta;)),
						m<sub>B</sub> = &Theta;((||f||<sub>&infin;</sub>/&eta;)<sup>2</sup> * ln(||f||<sub>&infin;</sub>/&delta;&gamma;))<br>
						
						where &delta; = &delta;'/&Theta;(1/&tau; * (||f||<sub>2</sub><sup>2</sup>/&tau;)<sup>1.5</sup> * log|G|),
						&eta; = &Theta;(min{&gamma;, &radic;&gamma;, &gamma;/||f||<sub>&infin;</sub>})
						</center><br>
						The second option usage requires: &delta;', ||f||<sub>2</sub>, ||f||<sub>&infin;</sub>, the constant for the tight-bound in &delta; calculation,
						the constants for the tight-bounds in m<sub>A</sub> and m<sub>B</sub> calculation and the constant for the tight-bound in &eta; calculation.
					</li>
					<li>
						<b>Number of iterations</b>: the simpler method, the one using a given m<sub>A</sub> and m<sub>B</sub>, has an optional <i>numOfIterations</i>
						parameter. This parameter is for a suggested improvement for the percision of the SFT output. If the given number of iterations is bigger than 1,
						each iteration i reruns the SFT significant elements calculation over the same generated Q, over the difference function &fnof;-&fnof;<sub>i-1</sub>:
						the difference between the given function and the output function of the previous iteration.
					</li>
				</ul>
				
				The Function package allows the user to define a function object to be sent as the <b>query access</b> in the SFT
				implementation. Hierarchy:
				<ul>
					<li>
						Abstract class <b>Function</b>:<br>
						The basic function object, has two abstract extensions corresponding to the different optional function
						domain: Cartesian product of finite groups or Abelian group. There are three main procedures for this object:
						<i>getValue, calcInfinityNorm</i> and <i>calcEuclideanNorm</i>.
						<ul>
						<li>
							Abstract class <b>DirectProdFunction</b>: an abstract extension to class Function, for describing functions
							over Z<sub>N1</sub> x ... x Z<sub>Nk</sub> &rarr; C. It provides a naive implementation of the <i>calcInfinityNorm</i>
							and <i>calcEuclideanNorm</i> that are not recommended for use (very long calculation that iterates over
							all the elements in G).<br>
							The Function package also includes two implementations for the DirectProdFunction:
							<ul>
							<li>
								Class <b>FourierPolynomial</b>: extends class DirectProdFunction and describes a Fourier polynomial
								by a list of terms and their coefficients, i.e. for a Fourier polynomial:<br>
								p(x) = &sum;c<sub>&alpha;</sub>&bull;&Chi;<sub>&alpha;</sub>(x) it holds the mapping of &alpha;
								to its coefficient c<sub>&alpha;</sub>.
							</li>
							<li>
								Class <b>XMLFourierPolynomial</b>: extends class DirectProdFunction and describes a Fourier polynomial
								as class FourierPolynomial, allowing the user to construct it from a XML description of the function.
								In addition this implementation can receive multiple functions in one XML, and let the user choose which
								of the functions to use or randomly choose a function from the given list at each calculation.
							</li>
							</ul>
						</li>
						<li>
							Abstract class <b>FiniteAbelianFunction</b>: an abstract extension to class Function, for describing functions
							over a finite Abelian group G &rarr; C. 
						</li>
						</ul>
					</li>
				</ul>
				
				<br>
				
				<h3>Usage</h3>
				In order to use the SFT library in your Java project, follow these steps:
				<ul>
					<li>
						<b>Download</b>: download the SFT jar file (link below under <b>Tools and Downloads</b>).
					</li>
					<li>
						<b>Import</b>: import the library into your Java project.
					</li>
					<li>
						<b>Use</b>: import <i>SFT.*</i> and <i>Function.*</i> in your Java code and start using it! use the Function
						documentation to understand how to describe your function as a SFT-suitable input.
					</li>
				</ul>
				
				<b>Tools and Downloads:</b><br>
				<ul>
					<li>
						<a href="sft_lib.jar">The SFT JAR file</a>.
					</li>
					<li>
						<a href="javadoc/index.html">Java Documentation</a>.
					</li>
					<li>
						<a href="http://code.google.com/p/tau-cs-spring2010-workshop-sft-elizabeth-ariel/source/browse/#svn/trunk" target=_new>Google-code</a>.
					</li>
				</ul>
				 
				<br>
				<b><center>Browse this site: <a href="index.html">Home</a> | <a href="java.html">Java Usage</a> | <a href="matlab.html">Matlab Usage</a></center></b>  
				<br>
				<center>Created by Elizabeth Firman &amp; Ariel Stolerman, CS Workshop, TAU Spring 2010</center>
			
			</div>
			
			<center><font size=1pt>This page is best viewed in Mozilla FireFox</font></center>
		</div>
		</center>
		
	</body>
</html>